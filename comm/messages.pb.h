// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_messages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_messages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_messages_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_messages_2eproto;
namespace lilsim {
class AdminCommand;
class AdminCommandDefaultTypeInternal;
extern AdminCommandDefaultTypeInternal _AdminCommand_default_instance_;
class AdminReply;
class AdminReplyDefaultTypeInternal;
extern AdminReplyDefaultTypeInternal _AdminReply_default_instance_;
class CarState;
class CarStateDefaultTypeInternal;
extern CarStateDefaultTypeInternal _CarState_default_instance_;
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class ControlAsync;
class ControlAsyncDefaultTypeInternal;
extern ControlAsyncDefaultTypeInternal _ControlAsync_default_instance_;
class ControlReply;
class ControlReplyDefaultTypeInternal;
extern ControlReplyDefaultTypeInternal _ControlReply_default_instance_;
class ControlRequest;
class ControlRequestDefaultTypeInternal;
extern ControlRequestDefaultTypeInternal _ControlRequest_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Marker;
class MarkerDefaultTypeInternal;
extern MarkerDefaultTypeInternal _Marker_default_instance_;
class MarkerArray;
class MarkerArrayDefaultTypeInternal;
extern MarkerArrayDefaultTypeInternal _MarkerArray_default_instance_;
class MarkerCommand;
class MarkerCommandDefaultTypeInternal;
extern MarkerCommandDefaultTypeInternal _MarkerCommand_default_instance_;
class Pose;
class PoseDefaultTypeInternal;
extern PoseDefaultTypeInternal _Pose_default_instance_;
class SE2;
class SE2DefaultTypeInternal;
extern SE2DefaultTypeInternal _SE2_default_instance_;
class Scale2D;
class Scale2DDefaultTypeInternal;
extern Scale2DDefaultTypeInternal _Scale2D_default_instance_;
class SceneState;
class SceneStateDefaultTypeInternal;
extern SceneStateDefaultTypeInternal _SceneState_default_instance_;
class SimParams;
class SimParamsDefaultTypeInternal;
extern SimParamsDefaultTypeInternal _SimParams_default_instance_;
class StateUpdate;
class StateUpdateDefaultTypeInternal;
extern StateUpdateDefaultTypeInternal _StateUpdate_default_instance_;
class Vec2;
class Vec2DefaultTypeInternal;
extern Vec2DefaultTypeInternal _Vec2_default_instance_;
}  // namespace lilsim
PROTOBUF_NAMESPACE_OPEN
template<> ::lilsim::AdminCommand* Arena::CreateMaybeMessage<::lilsim::AdminCommand>(Arena*);
template<> ::lilsim::AdminReply* Arena::CreateMaybeMessage<::lilsim::AdminReply>(Arena*);
template<> ::lilsim::CarState* Arena::CreateMaybeMessage<::lilsim::CarState>(Arena*);
template<> ::lilsim::Color* Arena::CreateMaybeMessage<::lilsim::Color>(Arena*);
template<> ::lilsim::ControlAsync* Arena::CreateMaybeMessage<::lilsim::ControlAsync>(Arena*);
template<> ::lilsim::ControlReply* Arena::CreateMaybeMessage<::lilsim::ControlReply>(Arena*);
template<> ::lilsim::ControlRequest* Arena::CreateMaybeMessage<::lilsim::ControlRequest>(Arena*);
template<> ::lilsim::Header* Arena::CreateMaybeMessage<::lilsim::Header>(Arena*);
template<> ::lilsim::Marker* Arena::CreateMaybeMessage<::lilsim::Marker>(Arena*);
template<> ::lilsim::MarkerArray* Arena::CreateMaybeMessage<::lilsim::MarkerArray>(Arena*);
template<> ::lilsim::MarkerCommand* Arena::CreateMaybeMessage<::lilsim::MarkerCommand>(Arena*);
template<> ::lilsim::Pose* Arena::CreateMaybeMessage<::lilsim::Pose>(Arena*);
template<> ::lilsim::SE2* Arena::CreateMaybeMessage<::lilsim::SE2>(Arena*);
template<> ::lilsim::Scale2D* Arena::CreateMaybeMessage<::lilsim::Scale2D>(Arena*);
template<> ::lilsim::SceneState* Arena::CreateMaybeMessage<::lilsim::SceneState>(Arena*);
template<> ::lilsim::SimParams* Arena::CreateMaybeMessage<::lilsim::SimParams>(Arena*);
template<> ::lilsim::StateUpdate* Arena::CreateMaybeMessage<::lilsim::StateUpdate>(Arena*);
template<> ::lilsim::Vec2* Arena::CreateMaybeMessage<::lilsim::Vec2>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace lilsim {

enum AdminCommandType : int {
  INIT = 0,
  RESET = 1,
  PAUSE = 2,
  RUN = 3,
  STEP = 4,
  SET_PARAMS = 5,
  SET_MODE = 6,
  AdminCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AdminCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AdminCommandType_IsValid(int value);
constexpr AdminCommandType AdminCommandType_MIN = INIT;
constexpr AdminCommandType AdminCommandType_MAX = SET_MODE;
constexpr int AdminCommandType_ARRAYSIZE = AdminCommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AdminCommandType_descriptor();
template<typename T>
inline const std::string& AdminCommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AdminCommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AdminCommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AdminCommandType_descriptor(), enum_t_value);
}
inline bool AdminCommandType_Parse(
    const std::string& name, AdminCommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AdminCommandType>(
    AdminCommandType_descriptor(), name, value);
}
enum SteeringInputMode : int {
  ANGLE = 0,
  RATE = 1,
  SteeringInputMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SteeringInputMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SteeringInputMode_IsValid(int value);
constexpr SteeringInputMode SteeringInputMode_MIN = ANGLE;
constexpr SteeringInputMode SteeringInputMode_MAX = RATE;
constexpr int SteeringInputMode_ARRAYSIZE = SteeringInputMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SteeringInputMode_descriptor();
template<typename T>
inline const std::string& SteeringInputMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SteeringInputMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SteeringInputMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SteeringInputMode_descriptor(), enum_t_value);
}
inline bool SteeringInputMode_Parse(
    const std::string& name, SteeringInputMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SteeringInputMode>(
    SteeringInputMode_descriptor(), name, value);
}
enum MarkerType : int {
  TEXT = 0,
  ARROW = 1,
  RECTANGLE = 2,
  CIRCLE = 3,
  LINE_LIST = 4,
  LINE_STRIP = 5,
  RECTANGLE_LIST = 6,
  CIRCLE_LIST = 7,
  POINTS = 8,
  TRIANGLE_LIST = 9,
  MESH_2D = 10,
  MarkerType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MarkerType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MarkerType_IsValid(int value);
constexpr MarkerType MarkerType_MIN = TEXT;
constexpr MarkerType MarkerType_MAX = MESH_2D;
constexpr int MarkerType_ARRAYSIZE = MarkerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarkerType_descriptor();
template<typename T>
inline const std::string& MarkerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarkerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarkerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarkerType_descriptor(), enum_t_value);
}
inline bool MarkerType_Parse(
    const std::string& name, MarkerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarkerType>(
    MarkerType_descriptor(), name, value);
}
enum MarkerCommandType : int {
  DELETE_MARKER = 0,
  DELETE_NAMESPACE = 1,
  CLEAR_ALL = 2,
  MarkerCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MarkerCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MarkerCommandType_IsValid(int value);
constexpr MarkerCommandType MarkerCommandType_MIN = DELETE_MARKER;
constexpr MarkerCommandType MarkerCommandType_MAX = CLEAR_ALL;
constexpr int MarkerCommandType_ARRAYSIZE = MarkerCommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MarkerCommandType_descriptor();
template<typename T>
inline const std::string& MarkerCommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MarkerCommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MarkerCommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MarkerCommandType_descriptor(), enum_t_value);
}
inline bool MarkerCommandType_Parse(
    const std::string& name, MarkerCommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MarkerCommandType>(
    MarkerCommandType_descriptor(), name, value);
}
// ===================================================================

class Header PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.Header) */ {
 public:
  inline Header() : Header(nullptr) {};
  virtual ~Header();

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(nullptr);
  }

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTickFieldNumber = 1,
    kSimTimeFieldNumber = 2,
    kVersionFieldNumber = 3,
  };
  // uint64 tick = 1;
  void clear_tick();
  ::PROTOBUF_NAMESPACE_ID::uint64 tick() const;
  void set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_tick() const;
  void _internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // double sim_time = 2;
  void clear_sim_time();
  double sim_time() const;
  void set_sim_time(double value);
  private:
  double _internal_sim_time() const;
  void _internal_set_sim_time(double value);
  public:

  // uint32 version = 3;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 tick_;
  double sim_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Vec2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.Vec2) */ {
 public:
  inline Vec2() : Vec2(nullptr) {};
  virtual ~Vec2();

  Vec2(const Vec2& from);
  Vec2(Vec2&& from) noexcept
    : Vec2() {
    *this = ::std::move(from);
  }

  inline Vec2& operator=(const Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec2& operator=(Vec2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec2* internal_default_instance() {
    return reinterpret_cast<const Vec2*>(
               &_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Vec2& a, Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vec2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec2* New() const final {
    return CreateMaybeMessage<Vec2>(nullptr);
  }

  Vec2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec2& from);
  void MergeFrom(const Vec2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.Vec2";
  }
  protected:
  explicit Vec2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.Vec2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class CarState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.CarState) */ {
 public:
  inline CarState() : CarState(nullptr) {};
  virtual ~CarState();

  CarState(const CarState& from);
  CarState(CarState&& from) noexcept
    : CarState() {
    *this = ::std::move(from);
  }

  inline CarState& operator=(const CarState& from) {
    CopyFrom(from);
    return *this;
  }
  inline CarState& operator=(CarState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CarState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CarState* internal_default_instance() {
    return reinterpret_cast<const CarState*>(
               &_CarState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CarState& a, CarState& b) {
    a.Swap(&b);
  }
  inline void Swap(CarState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CarState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CarState* New() const final {
    return CreateMaybeMessage<CarState>(nullptr);
  }

  CarState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CarState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CarState& from);
  void MergeFrom(const CarState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CarState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.CarState";
  }
  protected:
  explicit CarState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosFieldNumber = 1,
    kYawFieldNumber = 2,
    kVFieldNumber = 3,
    kYawRateFieldNumber = 4,
  };
  // .lilsim.Vec2 pos = 1;
  bool has_pos() const;
  private:
  bool _internal_has_pos() const;
  public:
  void clear_pos();
  const ::lilsim::Vec2& pos() const;
  ::lilsim::Vec2* release_pos();
  ::lilsim::Vec2* mutable_pos();
  void set_allocated_pos(::lilsim::Vec2* pos);
  private:
  const ::lilsim::Vec2& _internal_pos() const;
  ::lilsim::Vec2* _internal_mutable_pos();
  public:
  void unsafe_arena_set_allocated_pos(
      ::lilsim::Vec2* pos);
  ::lilsim::Vec2* unsafe_arena_release_pos();

  // double yaw = 2;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // double v = 3;
  void clear_v();
  double v() const;
  void set_v(double value);
  private:
  double _internal_v() const;
  void _internal_set_v(double value);
  public:

  // double yaw_rate = 4;
  void clear_yaw_rate();
  double yaw_rate() const;
  void set_yaw_rate(double value);
  private:
  double _internal_yaw_rate() const;
  void _internal_set_yaw_rate(double value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.CarState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::Vec2* pos_;
  double yaw_;
  double v_;
  double yaw_rate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SceneState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.SceneState) */ {
 public:
  inline SceneState() : SceneState(nullptr) {};
  virtual ~SceneState();

  SceneState(const SceneState& from);
  SceneState(SceneState&& from) noexcept
    : SceneState() {
    *this = ::std::move(from);
  }

  inline SceneState& operator=(const SceneState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneState& operator=(SceneState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SceneState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SceneState* internal_default_instance() {
    return reinterpret_cast<const SceneState*>(
               &_SceneState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SceneState& a, SceneState& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SceneState* New() const final {
    return CreateMaybeMessage<SceneState>(nullptr);
  }

  SceneState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SceneState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SceneState& from);
  void MergeFrom(const SceneState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.SceneState";
  }
  protected:
  explicit SceneState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kCarFieldNumber = 2,
  };
  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // .lilsim.CarState car = 2;
  bool has_car() const;
  private:
  bool _internal_has_car() const;
  public:
  void clear_car();
  const ::lilsim::CarState& car() const;
  ::lilsim::CarState* release_car();
  ::lilsim::CarState* mutable_car();
  void set_allocated_car(::lilsim::CarState* car);
  private:
  const ::lilsim::CarState& _internal_car() const;
  ::lilsim::CarState* _internal_mutable_car();
  public:
  void unsafe_arena_set_allocated_car(
      ::lilsim::CarState* car);
  ::lilsim::CarState* unsafe_arena_release_car();

  // @@protoc_insertion_point(class_scope:lilsim.SceneState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::Header* header_;
  ::lilsim::CarState* car_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class StateUpdate PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.StateUpdate) */ {
 public:
  inline StateUpdate() : StateUpdate(nullptr) {};
  virtual ~StateUpdate();

  StateUpdate(const StateUpdate& from);
  StateUpdate(StateUpdate&& from) noexcept
    : StateUpdate() {
    *this = ::std::move(from);
  }

  inline StateUpdate& operator=(const StateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateUpdate& operator=(StateUpdate&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StateUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StateUpdate* internal_default_instance() {
    return reinterpret_cast<const StateUpdate*>(
               &_StateUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StateUpdate& a, StateUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(StateUpdate* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StateUpdate* New() const final {
    return CreateMaybeMessage<StateUpdate>(nullptr);
  }

  StateUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StateUpdate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StateUpdate& from);
  void MergeFrom(const StateUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateUpdate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.StateUpdate";
  }
  protected:
  explicit StateUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceneFieldNumber = 1,
  };
  // .lilsim.SceneState scene = 1;
  bool has_scene() const;
  private:
  bool _internal_has_scene() const;
  public:
  void clear_scene();
  const ::lilsim::SceneState& scene() const;
  ::lilsim::SceneState* release_scene();
  ::lilsim::SceneState* mutable_scene();
  void set_allocated_scene(::lilsim::SceneState* scene);
  private:
  const ::lilsim::SceneState& _internal_scene() const;
  ::lilsim::SceneState* _internal_mutable_scene();
  public:
  void unsafe_arena_set_allocated_scene(
      ::lilsim::SceneState* scene);
  ::lilsim::SceneState* unsafe_arena_release_scene();

  // @@protoc_insertion_point(class_scope:lilsim.StateUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::SceneState* scene_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ControlAsync PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.ControlAsync) */ {
 public:
  inline ControlAsync() : ControlAsync(nullptr) {};
  virtual ~ControlAsync();

  ControlAsync(const ControlAsync& from);
  ControlAsync(ControlAsync&& from) noexcept
    : ControlAsync() {
    *this = ::std::move(from);
  }

  inline ControlAsync& operator=(const ControlAsync& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlAsync& operator=(ControlAsync&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlAsync& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlAsync* internal_default_instance() {
    return reinterpret_cast<const ControlAsync*>(
               &_ControlAsync_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ControlAsync& a, ControlAsync& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlAsync* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlAsync* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlAsync* New() const final {
    return CreateMaybeMessage<ControlAsync>(nullptr);
  }

  ControlAsync* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlAsync>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlAsync& from);
  void MergeFrom(const ControlAsync& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlAsync* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.ControlAsync";
  }
  protected:
  explicit ControlAsync(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSteerAngleFieldNumber = 2,
    kSteerRateFieldNumber = 3,
    kAxFieldNumber = 4,
  };
  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // double steer_angle = 2;
  void clear_steer_angle();
  double steer_angle() const;
  void set_steer_angle(double value);
  private:
  double _internal_steer_angle() const;
  void _internal_set_steer_angle(double value);
  public:

  // double steer_rate = 3;
  void clear_steer_rate();
  double steer_rate() const;
  void set_steer_rate(double value);
  private:
  double _internal_steer_rate() const;
  void _internal_set_steer_rate(double value);
  public:

  // double ax = 4;
  void clear_ax();
  double ax() const;
  void set_ax(double value);
  private:
  double _internal_ax() const;
  void _internal_set_ax(double value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.ControlAsync)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::Header* header_;
  double steer_angle_;
  double steer_rate_;
  double ax_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ControlRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.ControlRequest) */ {
 public:
  inline ControlRequest() : ControlRequest(nullptr) {};
  virtual ~ControlRequest();

  ControlRequest(const ControlRequest& from);
  ControlRequest(ControlRequest&& from) noexcept
    : ControlRequest() {
    *this = ::std::move(from);
  }

  inline ControlRequest& operator=(const ControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlRequest& operator=(ControlRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlRequest* internal_default_instance() {
    return reinterpret_cast<const ControlRequest*>(
               &_ControlRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ControlRequest& a, ControlRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlRequest* New() const final {
    return CreateMaybeMessage<ControlRequest>(nullptr);
  }

  ControlRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlRequest& from);
  void MergeFrom(const ControlRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.ControlRequest";
  }
  protected:
  explicit ControlRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSceneFieldNumber = 2,
  };
  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // .lilsim.SceneState scene = 2;
  bool has_scene() const;
  private:
  bool _internal_has_scene() const;
  public:
  void clear_scene();
  const ::lilsim::SceneState& scene() const;
  ::lilsim::SceneState* release_scene();
  ::lilsim::SceneState* mutable_scene();
  void set_allocated_scene(::lilsim::SceneState* scene);
  private:
  const ::lilsim::SceneState& _internal_scene() const;
  ::lilsim::SceneState* _internal_mutable_scene();
  public:
  void unsafe_arena_set_allocated_scene(
      ::lilsim::SceneState* scene);
  ::lilsim::SceneState* unsafe_arena_release_scene();

  // @@protoc_insertion_point(class_scope:lilsim.ControlRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::Header* header_;
  ::lilsim::SceneState* scene_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class ControlReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.ControlReply) */ {
 public:
  inline ControlReply() : ControlReply(nullptr) {};
  virtual ~ControlReply();

  ControlReply(const ControlReply& from);
  ControlReply(ControlReply&& from) noexcept
    : ControlReply() {
    *this = ::std::move(from);
  }

  inline ControlReply& operator=(const ControlReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControlReply& operator=(ControlReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControlReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControlReply* internal_default_instance() {
    return reinterpret_cast<const ControlReply*>(
               &_ControlReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ControlReply& a, ControlReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ControlReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControlReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControlReply* New() const final {
    return CreateMaybeMessage<ControlReply>(nullptr);
  }

  ControlReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControlReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControlReply& from);
  void MergeFrom(const ControlReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControlReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.ControlReply";
  }
  protected:
  explicit ControlReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kSteerAngleFieldNumber = 2,
    kSteerRateFieldNumber = 3,
    kAxFieldNumber = 4,
  };
  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // double steer_angle = 2;
  void clear_steer_angle();
  double steer_angle() const;
  void set_steer_angle(double value);
  private:
  double _internal_steer_angle() const;
  void _internal_set_steer_angle(double value);
  public:

  // double steer_rate = 3;
  void clear_steer_rate();
  double steer_rate() const;
  void set_steer_rate(double value);
  private:
  double _internal_steer_rate() const;
  void _internal_set_steer_rate(double value);
  public:

  // double ax = 4;
  void clear_ax();
  double ax() const;
  void set_ax(double value);
  private:
  double _internal_ax() const;
  void _internal_set_ax(double value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.ControlReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::Header* header_;
  double steer_angle_;
  double steer_rate_;
  double ax_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SimParams PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.SimParams) */ {
 public:
  inline SimParams() : SimParams(nullptr) {};
  virtual ~SimParams();

  SimParams(const SimParams& from);
  SimParams(SimParams&& from) noexcept
    : SimParams() {
    *this = ::std::move(from);
  }

  inline SimParams& operator=(const SimParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline SimParams& operator=(SimParams&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SimParams& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SimParams* internal_default_instance() {
    return reinterpret_cast<const SimParams*>(
               &_SimParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SimParams& a, SimParams& b) {
    a.Swap(&b);
  }
  inline void Swap(SimParams* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SimParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SimParams* New() const final {
    return CreateMaybeMessage<SimParams>(nullptr);
  }

  SimParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SimParams>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SimParams& from);
  void MergeFrom(const SimParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SimParams* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.SimParams";
  }
  protected:
  explicit SimParams(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDtFieldNumber = 1,
    kWheelbaseFieldNumber = 2,
    kVMaxFieldNumber = 3,
    kDeltaMaxFieldNumber = 4,
    kLfFieldNumber = 5,
    kAxMaxFieldNumber = 6,
    kSteerRateMaxFieldNumber = 7,
    kSteeringModeFieldNumber = 8,
  };
  // double dt = 1;
  void clear_dt();
  double dt() const;
  void set_dt(double value);
  private:
  double _internal_dt() const;
  void _internal_set_dt(double value);
  public:

  // double wheelbase = 2;
  void clear_wheelbase();
  double wheelbase() const;
  void set_wheelbase(double value);
  private:
  double _internal_wheelbase() const;
  void _internal_set_wheelbase(double value);
  public:

  // double v_max = 3;
  void clear_v_max();
  double v_max() const;
  void set_v_max(double value);
  private:
  double _internal_v_max() const;
  void _internal_set_v_max(double value);
  public:

  // double delta_max = 4;
  void clear_delta_max();
  double delta_max() const;
  void set_delta_max(double value);
  private:
  double _internal_delta_max() const;
  void _internal_set_delta_max(double value);
  public:

  // double Lf = 5;
  void clear_lf();
  double lf() const;
  void set_lf(double value);
  private:
  double _internal_lf() const;
  void _internal_set_lf(double value);
  public:

  // double ax_max = 6;
  void clear_ax_max();
  double ax_max() const;
  void set_ax_max(double value);
  private:
  double _internal_ax_max() const;
  void _internal_set_ax_max(double value);
  public:

  // double steer_rate_max = 7;
  void clear_steer_rate_max();
  double steer_rate_max() const;
  void set_steer_rate_max(double value);
  private:
  double _internal_steer_rate_max() const;
  void _internal_set_steer_rate_max(double value);
  public:

  // .lilsim.SteeringInputMode steering_mode = 8;
  void clear_steering_mode();
  ::lilsim::SteeringInputMode steering_mode() const;
  void set_steering_mode(::lilsim::SteeringInputMode value);
  private:
  ::lilsim::SteeringInputMode _internal_steering_mode() const;
  void _internal_set_steering_mode(::lilsim::SteeringInputMode value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.SimParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double dt_;
  double wheelbase_;
  double v_max_;
  double delta_max_;
  double lf_;
  double ax_max_;
  double steer_rate_max_;
  int steering_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class AdminCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.AdminCommand) */ {
 public:
  inline AdminCommand() : AdminCommand(nullptr) {};
  virtual ~AdminCommand();

  AdminCommand(const AdminCommand& from);
  AdminCommand(AdminCommand&& from) noexcept
    : AdminCommand() {
    *this = ::std::move(from);
  }

  inline AdminCommand& operator=(const AdminCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminCommand& operator=(AdminCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdminCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminCommand* internal_default_instance() {
    return reinterpret_cast<const AdminCommand*>(
               &_AdminCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AdminCommand& a, AdminCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdminCommand* New() const final {
    return CreateMaybeMessage<AdminCommand>(nullptr);
  }

  AdminCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdminCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdminCommand& from);
  void MergeFrom(const AdminCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.AdminCommand";
  }
  protected:
  explicit AdminCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeaderFieldNumber = 1,
    kParamsFieldNumber = 4,
    kStepCountFieldNumber = 3,
    kTypeFieldNumber = 2,
    kSyncModeFieldNumber = 5,
    kControlPeriodMsFieldNumber = 6,
  };
  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // .lilsim.SimParams params = 4;
  bool has_params() const;
  private:
  bool _internal_has_params() const;
  public:
  void clear_params();
  const ::lilsim::SimParams& params() const;
  ::lilsim::SimParams* release_params();
  ::lilsim::SimParams* mutable_params();
  void set_allocated_params(::lilsim::SimParams* params);
  private:
  const ::lilsim::SimParams& _internal_params() const;
  ::lilsim::SimParams* _internal_mutable_params();
  public:
  void unsafe_arena_set_allocated_params(
      ::lilsim::SimParams* params);
  ::lilsim::SimParams* unsafe_arena_release_params();

  // uint64 step_count = 3;
  void clear_step_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 step_count() const;
  void set_step_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_step_count() const;
  void _internal_set_step_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .lilsim.AdminCommandType type = 2;
  void clear_type();
  ::lilsim::AdminCommandType type() const;
  void set_type(::lilsim::AdminCommandType value);
  private:
  ::lilsim::AdminCommandType _internal_type() const;
  void _internal_set_type(::lilsim::AdminCommandType value);
  public:

  // bool sync_mode = 5;
  void clear_sync_mode();
  bool sync_mode() const;
  void set_sync_mode(bool value);
  private:
  bool _internal_sync_mode() const;
  void _internal_set_sync_mode(bool value);
  public:

  // uint32 control_period_ms = 6;
  void clear_control_period_ms();
  ::PROTOBUF_NAMESPACE_ID::uint32 control_period_ms() const;
  void set_control_period_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_control_period_ms() const;
  void _internal_set_control_period_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.AdminCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::lilsim::Header* header_;
  ::lilsim::SimParams* params_;
  ::PROTOBUF_NAMESPACE_ID::uint64 step_count_;
  int type_;
  bool sync_mode_;
  ::PROTOBUF_NAMESPACE_ID::uint32 control_period_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class AdminReply PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.AdminReply) */ {
 public:
  inline AdminReply() : AdminReply(nullptr) {};
  virtual ~AdminReply();

  AdminReply(const AdminReply& from);
  AdminReply(AdminReply&& from) noexcept
    : AdminReply() {
    *this = ::std::move(from);
  }

  inline AdminReply& operator=(const AdminReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminReply& operator=(AdminReply&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AdminReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AdminReply* internal_default_instance() {
    return reinterpret_cast<const AdminReply*>(
               &_AdminReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(AdminReply& a, AdminReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminReply* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AdminReply* New() const final {
    return CreateMaybeMessage<AdminReply>(nullptr);
  }

  AdminReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AdminReply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AdminReply& from);
  void MergeFrom(const AdminReply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminReply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.AdminReply";
  }
  protected:
  explicit AdminReply(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // string message = 3;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.AdminReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::lilsim::Header* header_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Color PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.Color) */ {
 public:
  inline Color() : Color(nullptr) {};
  virtual ~Color();

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(nullptr);
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
    kGFieldNumber = 2,
    kBFieldNumber = 3,
    kAFieldNumber = 4,
  };
  // uint32 r = 1;
  void clear_r();
  ::PROTOBUF_NAMESPACE_ID::uint32 r() const;
  void set_r(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_r() const;
  void _internal_set_r(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 g = 2;
  void clear_g();
  ::PROTOBUF_NAMESPACE_ID::uint32 g() const;
  void set_g(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_g() const;
  void _internal_set_g(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 b = 3;
  void clear_b();
  ::PROTOBUF_NAMESPACE_ID::uint32 b() const;
  void set_b(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_b() const;
  void _internal_set_b(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 a = 4;
  void clear_a();
  ::PROTOBUF_NAMESPACE_ID::uint32 a() const;
  void set_a(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_a() const;
  void _internal_set_a(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 r_;
  ::PROTOBUF_NAMESPACE_ID::uint32 g_;
  ::PROTOBUF_NAMESPACE_ID::uint32 b_;
  ::PROTOBUF_NAMESPACE_ID::uint32 a_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Scale2D PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.Scale2D) */ {
 public:
  inline Scale2D() : Scale2D(nullptr) {};
  virtual ~Scale2D();

  Scale2D(const Scale2D& from);
  Scale2D(Scale2D&& from) noexcept
    : Scale2D() {
    *this = ::std::move(from);
  }

  inline Scale2D& operator=(const Scale2D& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scale2D& operator=(Scale2D&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Scale2D& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scale2D* internal_default_instance() {
    return reinterpret_cast<const Scale2D*>(
               &_Scale2D_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Scale2D& a, Scale2D& b) {
    a.Swap(&b);
  }
  inline void Swap(Scale2D* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Scale2D* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Scale2D* New() const final {
    return CreateMaybeMessage<Scale2D>(nullptr);
  }

  Scale2D* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Scale2D>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Scale2D& from);
  void MergeFrom(const Scale2D& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scale2D* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.Scale2D";
  }
  protected:
  explicit Scale2D(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.Scale2D)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float x_;
  float y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class SE2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.SE2) */ {
 public:
  inline SE2() : SE2(nullptr) {};
  virtual ~SE2();

  SE2(const SE2& from);
  SE2(SE2&& from) noexcept
    : SE2() {
    *this = ::std::move(from);
  }

  inline SE2& operator=(const SE2& from) {
    CopyFrom(from);
    return *this;
  }
  inline SE2& operator=(SE2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SE2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SE2* internal_default_instance() {
    return reinterpret_cast<const SE2*>(
               &_SE2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SE2& a, SE2& b) {
    a.Swap(&b);
  }
  inline void Swap(SE2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SE2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SE2* New() const final {
    return CreateMaybeMessage<SE2>(nullptr);
  }

  SE2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SE2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SE2& from);
  void MergeFrom(const SE2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SE2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.SE2";
  }
  protected:
  explicit SE2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double yaw = 3;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.SE2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Pose PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.Pose) */ {
 public:
  inline Pose() : Pose(nullptr) {};
  virtual ~Pose();

  Pose(const Pose& from);
  Pose(Pose&& from) noexcept
    : Pose() {
    *this = ::std::move(from);
  }

  inline Pose& operator=(const Pose& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pose& operator=(Pose&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Pose& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pose* internal_default_instance() {
    return reinterpret_cast<const Pose*>(
               &_Pose_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Pose& a, Pose& b) {
    a.Swap(&b);
  }
  inline void Swap(Pose* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pose* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Pose* New() const final {
    return CreateMaybeMessage<Pose>(nullptr);
  }

  Pose* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Pose>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Pose& from);
  void MergeFrom(const Pose& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pose* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.Pose";
  }
  protected:
  explicit Pose(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kYawFieldNumber = 3,
  };
  // double x = 1;
  void clear_x();
  double x() const;
  void set_x(double value);
  private:
  double _internal_x() const;
  void _internal_set_x(double value);
  public:

  // double y = 2;
  void clear_y();
  double y() const;
  void set_y(double value);
  private:
  double _internal_y() const;
  void _internal_set_y(double value);
  public:

  // double yaw = 3;
  void clear_yaw();
  double yaw() const;
  void set_yaw(double value);
  private:
  double _internal_yaw() const;
  void _internal_set_yaw(double value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.Pose)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double x_;
  double y_;
  double yaw_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class Marker PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.Marker) */ {
 public:
  inline Marker() : Marker(nullptr) {};
  virtual ~Marker();

  Marker(const Marker& from);
  Marker(Marker&& from) noexcept
    : Marker() {
    *this = ::std::move(from);
  }

  inline Marker& operator=(const Marker& from) {
    CopyFrom(from);
    return *this;
  }
  inline Marker& operator=(Marker&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Marker& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Marker* internal_default_instance() {
    return reinterpret_cast<const Marker*>(
               &_Marker_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Marker& a, Marker& b) {
    a.Swap(&b);
  }
  inline void Swap(Marker* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Marker* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Marker* New() const final {
    return CreateMaybeMessage<Marker>(nullptr);
  }

  Marker* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Marker>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Marker& from);
  void MergeFrom(const Marker& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Marker* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.Marker";
  }
  protected:
  explicit Marker(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 8,
    kNsFieldNumber = 1,
    kTextFieldNumber = 7,
    kPoseFieldNumber = 4,
    kColorFieldNumber = 5,
    kScaleFieldNumber = 6,
    kIdFieldNumber = 2,
    kTypeFieldNumber = 3,
    kTtlSecFieldNumber = 9,
    kVisibleFieldNumber = 10,
  };
  // repeated .lilsim.Pose points = 8;
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::lilsim::Pose* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Pose >*
      mutable_points();
  private:
  const ::lilsim::Pose& _internal_points(int index) const;
  ::lilsim::Pose* _internal_add_points();
  public:
  const ::lilsim::Pose& points(int index) const;
  ::lilsim::Pose* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Pose >&
      points() const;

  // string ns = 1;
  void clear_ns();
  const std::string& ns() const;
  void set_ns(const std::string& value);
  void set_ns(std::string&& value);
  void set_ns(const char* value);
  void set_ns(const char* value, size_t size);
  std::string* mutable_ns();
  std::string* release_ns();
  void set_allocated_ns(std::string* ns);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ns();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ns(
      std::string* ns);
  private:
  const std::string& _internal_ns() const;
  void _internal_set_ns(const std::string& value);
  std::string* _internal_mutable_ns();
  public:

  // string text = 7;
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_text();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_text(
      std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .lilsim.Pose pose = 4;
  bool has_pose() const;
  private:
  bool _internal_has_pose() const;
  public:
  void clear_pose();
  const ::lilsim::Pose& pose() const;
  ::lilsim::Pose* release_pose();
  ::lilsim::Pose* mutable_pose();
  void set_allocated_pose(::lilsim::Pose* pose);
  private:
  const ::lilsim::Pose& _internal_pose() const;
  ::lilsim::Pose* _internal_mutable_pose();
  public:
  void unsafe_arena_set_allocated_pose(
      ::lilsim::Pose* pose);
  ::lilsim::Pose* unsafe_arena_release_pose();

  // .lilsim.Color color = 5;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::lilsim::Color& color() const;
  ::lilsim::Color* release_color();
  ::lilsim::Color* mutable_color();
  void set_allocated_color(::lilsim::Color* color);
  private:
  const ::lilsim::Color& _internal_color() const;
  ::lilsim::Color* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::lilsim::Color* color);
  ::lilsim::Color* unsafe_arena_release_color();

  // .lilsim.Scale2D scale = 6;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::lilsim::Scale2D& scale() const;
  ::lilsim::Scale2D* release_scale();
  ::lilsim::Scale2D* mutable_scale();
  void set_allocated_scale(::lilsim::Scale2D* scale);
  private:
  const ::lilsim::Scale2D& _internal_scale() const;
  ::lilsim::Scale2D* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::lilsim::Scale2D* scale);
  ::lilsim::Scale2D* unsafe_arena_release_scale();

  // int32 id = 2;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .lilsim.MarkerType type = 3;
  void clear_type();
  ::lilsim::MarkerType type() const;
  void set_type(::lilsim::MarkerType value);
  private:
  ::lilsim::MarkerType _internal_type() const;
  void _internal_set_type(::lilsim::MarkerType value);
  public:

  // double ttl_sec = 9;
  void clear_ttl_sec();
  double ttl_sec() const;
  void set_ttl_sec(double value);
  private:
  double _internal_ttl_sec() const;
  void _internal_set_ttl_sec(double value);
  public:

  // bool visible = 10;
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.Marker)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Pose > points_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ns_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::lilsim::Pose* pose_;
  ::lilsim::Color* color_;
  ::lilsim::Scale2D* scale_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  int type_;
  double ttl_sec_;
  bool visible_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MarkerArray PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.MarkerArray) */ {
 public:
  inline MarkerArray() : MarkerArray(nullptr) {};
  virtual ~MarkerArray();

  MarkerArray(const MarkerArray& from);
  MarkerArray(MarkerArray&& from) noexcept
    : MarkerArray() {
    *this = ::std::move(from);
  }

  inline MarkerArray& operator=(const MarkerArray& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkerArray& operator=(MarkerArray&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarkerArray& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarkerArray* internal_default_instance() {
    return reinterpret_cast<const MarkerArray*>(
               &_MarkerArray_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(MarkerArray& a, MarkerArray& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkerArray* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkerArray* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MarkerArray* New() const final {
    return CreateMaybeMessage<MarkerArray>(nullptr);
  }

  MarkerArray* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarkerArray>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarkerArray& from);
  void MergeFrom(const MarkerArray& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkerArray* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.MarkerArray";
  }
  protected:
  explicit MarkerArray(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMarkersFieldNumber = 2,
    kHeaderFieldNumber = 1,
  };
  // repeated .lilsim.Marker markers = 2;
  int markers_size() const;
  private:
  int _internal_markers_size() const;
  public:
  void clear_markers();
  ::lilsim::Marker* mutable_markers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Marker >*
      mutable_markers();
  private:
  const ::lilsim::Marker& _internal_markers(int index) const;
  ::lilsim::Marker* _internal_add_markers();
  public:
  const ::lilsim::Marker& markers(int index) const;
  ::lilsim::Marker* add_markers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Marker >&
      markers() const;

  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // @@protoc_insertion_point(class_scope:lilsim.MarkerArray)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Marker > markers_;
  ::lilsim::Header* header_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// -------------------------------------------------------------------

class MarkerCommand PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:lilsim.MarkerCommand) */ {
 public:
  inline MarkerCommand() : MarkerCommand(nullptr) {};
  virtual ~MarkerCommand();

  MarkerCommand(const MarkerCommand& from);
  MarkerCommand(MarkerCommand&& from) noexcept
    : MarkerCommand() {
    *this = ::std::move(from);
  }

  inline MarkerCommand& operator=(const MarkerCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkerCommand& operator=(MarkerCommand&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MarkerCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarkerCommand* internal_default_instance() {
    return reinterpret_cast<const MarkerCommand*>(
               &_MarkerCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MarkerCommand& a, MarkerCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(MarkerCommand* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkerCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MarkerCommand* New() const final {
    return CreateMaybeMessage<MarkerCommand>(nullptr);
  }

  MarkerCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MarkerCommand>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MarkerCommand& from);
  void MergeFrom(const MarkerCommand& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarkerCommand* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "lilsim.MarkerCommand";
  }
  protected:
  explicit MarkerCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_messages_2eproto);
    return ::descriptor_table_messages_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNsFieldNumber = 3,
    kHeaderFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIdFieldNumber = 4,
  };
  // string ns = 3;
  void clear_ns();
  const std::string& ns() const;
  void set_ns(const std::string& value);
  void set_ns(std::string&& value);
  void set_ns(const char* value);
  void set_ns(const char* value, size_t size);
  std::string* mutable_ns();
  std::string* release_ns();
  void set_allocated_ns(std::string* ns);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ns();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ns(
      std::string* ns);
  private:
  const std::string& _internal_ns() const;
  void _internal_set_ns(const std::string& value);
  std::string* _internal_mutable_ns();
  public:

  // .lilsim.Header header = 1;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::lilsim::Header& header() const;
  ::lilsim::Header* release_header();
  ::lilsim::Header* mutable_header();
  void set_allocated_header(::lilsim::Header* header);
  private:
  const ::lilsim::Header& _internal_header() const;
  ::lilsim::Header* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::lilsim::Header* header);
  ::lilsim::Header* unsafe_arena_release_header();

  // .lilsim.MarkerCommandType type = 2;
  void clear_type();
  ::lilsim::MarkerCommandType type() const;
  void set_type(::lilsim::MarkerCommandType value);
  private:
  ::lilsim::MarkerCommandType _internal_type() const;
  void _internal_set_type(::lilsim::MarkerCommandType value);
  public:

  // int32 id = 4;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:lilsim.MarkerCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ns_;
  ::lilsim::Header* header_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::int32 id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_messages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Header

// uint64 tick = 1;
inline void Header::clear_tick() {
  tick_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Header::_internal_tick() const {
  return tick_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Header::tick() const {
  // @@protoc_insertion_point(field_get:lilsim.Header.tick)
  return _internal_tick();
}
inline void Header::_internal_set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  tick_ = value;
}
inline void Header::set_tick(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_tick(value);
  // @@protoc_insertion_point(field_set:lilsim.Header.tick)
}

// double sim_time = 2;
inline void Header::clear_sim_time() {
  sim_time_ = 0;
}
inline double Header::_internal_sim_time() const {
  return sim_time_;
}
inline double Header::sim_time() const {
  // @@protoc_insertion_point(field_get:lilsim.Header.sim_time)
  return _internal_sim_time();
}
inline void Header::_internal_set_sim_time(double value) {
  
  sim_time_ = value;
}
inline void Header::set_sim_time(double value) {
  _internal_set_sim_time(value);
  // @@protoc_insertion_point(field_set:lilsim.Header.sim_time)
}

// uint32 version = 3;
inline void Header::clear_version() {
  version_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Header::version() const {
  // @@protoc_insertion_point(field_get:lilsim.Header.version)
  return _internal_version();
}
inline void Header::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  version_ = value;
}
inline void Header::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:lilsim.Header.version)
}

// -------------------------------------------------------------------

// Vec2

// double x = 1;
inline void Vec2::clear_x() {
  x_ = 0;
}
inline double Vec2::_internal_x() const {
  return x_;
}
inline double Vec2::x() const {
  // @@protoc_insertion_point(field_get:lilsim.Vec2.x)
  return _internal_x();
}
inline void Vec2::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Vec2::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:lilsim.Vec2.x)
}

// double y = 2;
inline void Vec2::clear_y() {
  y_ = 0;
}
inline double Vec2::_internal_y() const {
  return y_;
}
inline double Vec2::y() const {
  // @@protoc_insertion_point(field_get:lilsim.Vec2.y)
  return _internal_y();
}
inline void Vec2::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Vec2::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:lilsim.Vec2.y)
}

// -------------------------------------------------------------------

// CarState

// .lilsim.Vec2 pos = 1;
inline bool CarState::_internal_has_pos() const {
  return this != internal_default_instance() && pos_ != nullptr;
}
inline bool CarState::has_pos() const {
  return _internal_has_pos();
}
inline void CarState::clear_pos() {
  if (GetArena() == nullptr && pos_ != nullptr) {
    delete pos_;
  }
  pos_ = nullptr;
}
inline const ::lilsim::Vec2& CarState::_internal_pos() const {
  const ::lilsim::Vec2* p = pos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Vec2*>(
      &::lilsim::_Vec2_default_instance_);
}
inline const ::lilsim::Vec2& CarState::pos() const {
  // @@protoc_insertion_point(field_get:lilsim.CarState.pos)
  return _internal_pos();
}
inline void CarState::unsafe_arena_set_allocated_pos(
    ::lilsim::Vec2* pos) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pos_);
  }
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.CarState.pos)
}
inline ::lilsim::Vec2* CarState::release_pos() {
  auto temp = unsafe_arena_release_pos();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Vec2* CarState::unsafe_arena_release_pos() {
  // @@protoc_insertion_point(field_release:lilsim.CarState.pos)
  
  ::lilsim::Vec2* temp = pos_;
  pos_ = nullptr;
  return temp;
}
inline ::lilsim::Vec2* CarState::_internal_mutable_pos() {
  
  if (pos_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Vec2>(GetArena());
    pos_ = p;
  }
  return pos_;
}
inline ::lilsim::Vec2* CarState::mutable_pos() {
  // @@protoc_insertion_point(field_mutable:lilsim.CarState.pos)
  return _internal_mutable_pos();
}
inline void CarState::set_allocated_pos(::lilsim::Vec2* pos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pos_;
  }
  if (pos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pos);
    if (message_arena != submessage_arena) {
      pos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    
  } else {
    
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:lilsim.CarState.pos)
}

// double yaw = 2;
inline void CarState::clear_yaw() {
  yaw_ = 0;
}
inline double CarState::_internal_yaw() const {
  return yaw_;
}
inline double CarState::yaw() const {
  // @@protoc_insertion_point(field_get:lilsim.CarState.yaw)
  return _internal_yaw();
}
inline void CarState::_internal_set_yaw(double value) {
  
  yaw_ = value;
}
inline void CarState::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:lilsim.CarState.yaw)
}

// double v = 3;
inline void CarState::clear_v() {
  v_ = 0;
}
inline double CarState::_internal_v() const {
  return v_;
}
inline double CarState::v() const {
  // @@protoc_insertion_point(field_get:lilsim.CarState.v)
  return _internal_v();
}
inline void CarState::_internal_set_v(double value) {
  
  v_ = value;
}
inline void CarState::set_v(double value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:lilsim.CarState.v)
}

// double yaw_rate = 4;
inline void CarState::clear_yaw_rate() {
  yaw_rate_ = 0;
}
inline double CarState::_internal_yaw_rate() const {
  return yaw_rate_;
}
inline double CarState::yaw_rate() const {
  // @@protoc_insertion_point(field_get:lilsim.CarState.yaw_rate)
  return _internal_yaw_rate();
}
inline void CarState::_internal_set_yaw_rate(double value) {
  
  yaw_rate_ = value;
}
inline void CarState::set_yaw_rate(double value) {
  _internal_set_yaw_rate(value);
  // @@protoc_insertion_point(field_set:lilsim.CarState.yaw_rate)
}

// -------------------------------------------------------------------

// SceneState

// .lilsim.Header header = 1;
inline bool SceneState::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool SceneState::has_header() const {
  return _internal_has_header();
}
inline void SceneState::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& SceneState::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& SceneState::header() const {
  // @@protoc_insertion_point(field_get:lilsim.SceneState.header)
  return _internal_header();
}
inline void SceneState::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.SceneState.header)
}
inline ::lilsim::Header* SceneState::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* SceneState::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.SceneState.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* SceneState::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* SceneState::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.SceneState.header)
  return _internal_mutable_header();
}
inline void SceneState::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.SceneState.header)
}

// .lilsim.CarState car = 2;
inline bool SceneState::_internal_has_car() const {
  return this != internal_default_instance() && car_ != nullptr;
}
inline bool SceneState::has_car() const {
  return _internal_has_car();
}
inline void SceneState::clear_car() {
  if (GetArena() == nullptr && car_ != nullptr) {
    delete car_;
  }
  car_ = nullptr;
}
inline const ::lilsim::CarState& SceneState::_internal_car() const {
  const ::lilsim::CarState* p = car_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::CarState*>(
      &::lilsim::_CarState_default_instance_);
}
inline const ::lilsim::CarState& SceneState::car() const {
  // @@protoc_insertion_point(field_get:lilsim.SceneState.car)
  return _internal_car();
}
inline void SceneState::unsafe_arena_set_allocated_car(
    ::lilsim::CarState* car) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(car_);
  }
  car_ = car;
  if (car) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.SceneState.car)
}
inline ::lilsim::CarState* SceneState::release_car() {
  auto temp = unsafe_arena_release_car();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::CarState* SceneState::unsafe_arena_release_car() {
  // @@protoc_insertion_point(field_release:lilsim.SceneState.car)
  
  ::lilsim::CarState* temp = car_;
  car_ = nullptr;
  return temp;
}
inline ::lilsim::CarState* SceneState::_internal_mutable_car() {
  
  if (car_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::CarState>(GetArena());
    car_ = p;
  }
  return car_;
}
inline ::lilsim::CarState* SceneState::mutable_car() {
  // @@protoc_insertion_point(field_mutable:lilsim.SceneState.car)
  return _internal_mutable_car();
}
inline void SceneState::set_allocated_car(::lilsim::CarState* car) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete car_;
  }
  if (car) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(car);
    if (message_arena != submessage_arena) {
      car = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, car, submessage_arena);
    }
    
  } else {
    
  }
  car_ = car;
  // @@protoc_insertion_point(field_set_allocated:lilsim.SceneState.car)
}

// -------------------------------------------------------------------

// StateUpdate

// .lilsim.SceneState scene = 1;
inline bool StateUpdate::_internal_has_scene() const {
  return this != internal_default_instance() && scene_ != nullptr;
}
inline bool StateUpdate::has_scene() const {
  return _internal_has_scene();
}
inline void StateUpdate::clear_scene() {
  if (GetArena() == nullptr && scene_ != nullptr) {
    delete scene_;
  }
  scene_ = nullptr;
}
inline const ::lilsim::SceneState& StateUpdate::_internal_scene() const {
  const ::lilsim::SceneState* p = scene_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::SceneState*>(
      &::lilsim::_SceneState_default_instance_);
}
inline const ::lilsim::SceneState& StateUpdate::scene() const {
  // @@protoc_insertion_point(field_get:lilsim.StateUpdate.scene)
  return _internal_scene();
}
inline void StateUpdate::unsafe_arena_set_allocated_scene(
    ::lilsim::SceneState* scene) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scene_);
  }
  scene_ = scene;
  if (scene) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.StateUpdate.scene)
}
inline ::lilsim::SceneState* StateUpdate::release_scene() {
  auto temp = unsafe_arena_release_scene();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::SceneState* StateUpdate::unsafe_arena_release_scene() {
  // @@protoc_insertion_point(field_release:lilsim.StateUpdate.scene)
  
  ::lilsim::SceneState* temp = scene_;
  scene_ = nullptr;
  return temp;
}
inline ::lilsim::SceneState* StateUpdate::_internal_mutable_scene() {
  
  if (scene_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::SceneState>(GetArena());
    scene_ = p;
  }
  return scene_;
}
inline ::lilsim::SceneState* StateUpdate::mutable_scene() {
  // @@protoc_insertion_point(field_mutable:lilsim.StateUpdate.scene)
  return _internal_mutable_scene();
}
inline void StateUpdate::set_allocated_scene(::lilsim::SceneState* scene) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scene_;
  }
  if (scene) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scene);
    if (message_arena != submessage_arena) {
      scene = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    
  } else {
    
  }
  scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:lilsim.StateUpdate.scene)
}

// -------------------------------------------------------------------

// ControlAsync

// .lilsim.Header header = 1;
inline bool ControlAsync::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ControlAsync::has_header() const {
  return _internal_has_header();
}
inline void ControlAsync::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& ControlAsync::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& ControlAsync::header() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlAsync.header)
  return _internal_header();
}
inline void ControlAsync::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.ControlAsync.header)
}
inline ::lilsim::Header* ControlAsync::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* ControlAsync::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.ControlAsync.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* ControlAsync::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* ControlAsync::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.ControlAsync.header)
  return _internal_mutable_header();
}
inline void ControlAsync::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.ControlAsync.header)
}

// double steer_angle = 2;
inline void ControlAsync::clear_steer_angle() {
  steer_angle_ = 0;
}
inline double ControlAsync::_internal_steer_angle() const {
  return steer_angle_;
}
inline double ControlAsync::steer_angle() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlAsync.steer_angle)
  return _internal_steer_angle();
}
inline void ControlAsync::_internal_set_steer_angle(double value) {
  
  steer_angle_ = value;
}
inline void ControlAsync::set_steer_angle(double value) {
  _internal_set_steer_angle(value);
  // @@protoc_insertion_point(field_set:lilsim.ControlAsync.steer_angle)
}

// double steer_rate = 3;
inline void ControlAsync::clear_steer_rate() {
  steer_rate_ = 0;
}
inline double ControlAsync::_internal_steer_rate() const {
  return steer_rate_;
}
inline double ControlAsync::steer_rate() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlAsync.steer_rate)
  return _internal_steer_rate();
}
inline void ControlAsync::_internal_set_steer_rate(double value) {
  
  steer_rate_ = value;
}
inline void ControlAsync::set_steer_rate(double value) {
  _internal_set_steer_rate(value);
  // @@protoc_insertion_point(field_set:lilsim.ControlAsync.steer_rate)
}

// double ax = 4;
inline void ControlAsync::clear_ax() {
  ax_ = 0;
}
inline double ControlAsync::_internal_ax() const {
  return ax_;
}
inline double ControlAsync::ax() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlAsync.ax)
  return _internal_ax();
}
inline void ControlAsync::_internal_set_ax(double value) {
  
  ax_ = value;
}
inline void ControlAsync::set_ax(double value) {
  _internal_set_ax(value);
  // @@protoc_insertion_point(field_set:lilsim.ControlAsync.ax)
}

// -------------------------------------------------------------------

// ControlRequest

// .lilsim.Header header = 1;
inline bool ControlRequest::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ControlRequest::has_header() const {
  return _internal_has_header();
}
inline void ControlRequest::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& ControlRequest::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& ControlRequest::header() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlRequest.header)
  return _internal_header();
}
inline void ControlRequest::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.ControlRequest.header)
}
inline ::lilsim::Header* ControlRequest::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* ControlRequest::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.ControlRequest.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* ControlRequest::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* ControlRequest::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.ControlRequest.header)
  return _internal_mutable_header();
}
inline void ControlRequest::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.ControlRequest.header)
}

// .lilsim.SceneState scene = 2;
inline bool ControlRequest::_internal_has_scene() const {
  return this != internal_default_instance() && scene_ != nullptr;
}
inline bool ControlRequest::has_scene() const {
  return _internal_has_scene();
}
inline void ControlRequest::clear_scene() {
  if (GetArena() == nullptr && scene_ != nullptr) {
    delete scene_;
  }
  scene_ = nullptr;
}
inline const ::lilsim::SceneState& ControlRequest::_internal_scene() const {
  const ::lilsim::SceneState* p = scene_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::SceneState*>(
      &::lilsim::_SceneState_default_instance_);
}
inline const ::lilsim::SceneState& ControlRequest::scene() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlRequest.scene)
  return _internal_scene();
}
inline void ControlRequest::unsafe_arena_set_allocated_scene(
    ::lilsim::SceneState* scene) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scene_);
  }
  scene_ = scene;
  if (scene) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.ControlRequest.scene)
}
inline ::lilsim::SceneState* ControlRequest::release_scene() {
  auto temp = unsafe_arena_release_scene();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::SceneState* ControlRequest::unsafe_arena_release_scene() {
  // @@protoc_insertion_point(field_release:lilsim.ControlRequest.scene)
  
  ::lilsim::SceneState* temp = scene_;
  scene_ = nullptr;
  return temp;
}
inline ::lilsim::SceneState* ControlRequest::_internal_mutable_scene() {
  
  if (scene_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::SceneState>(GetArena());
    scene_ = p;
  }
  return scene_;
}
inline ::lilsim::SceneState* ControlRequest::mutable_scene() {
  // @@protoc_insertion_point(field_mutable:lilsim.ControlRequest.scene)
  return _internal_mutable_scene();
}
inline void ControlRequest::set_allocated_scene(::lilsim::SceneState* scene) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scene_;
  }
  if (scene) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scene);
    if (message_arena != submessage_arena) {
      scene = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scene, submessage_arena);
    }
    
  } else {
    
  }
  scene_ = scene;
  // @@protoc_insertion_point(field_set_allocated:lilsim.ControlRequest.scene)
}

// -------------------------------------------------------------------

// ControlReply

// .lilsim.Header header = 1;
inline bool ControlReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool ControlReply::has_header() const {
  return _internal_has_header();
}
inline void ControlReply::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& ControlReply::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& ControlReply::header() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlReply.header)
  return _internal_header();
}
inline void ControlReply::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.ControlReply.header)
}
inline ::lilsim::Header* ControlReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* ControlReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.ControlReply.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* ControlReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* ControlReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.ControlReply.header)
  return _internal_mutable_header();
}
inline void ControlReply::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.ControlReply.header)
}

// double steer_angle = 2;
inline void ControlReply::clear_steer_angle() {
  steer_angle_ = 0;
}
inline double ControlReply::_internal_steer_angle() const {
  return steer_angle_;
}
inline double ControlReply::steer_angle() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlReply.steer_angle)
  return _internal_steer_angle();
}
inline void ControlReply::_internal_set_steer_angle(double value) {
  
  steer_angle_ = value;
}
inline void ControlReply::set_steer_angle(double value) {
  _internal_set_steer_angle(value);
  // @@protoc_insertion_point(field_set:lilsim.ControlReply.steer_angle)
}

// double steer_rate = 3;
inline void ControlReply::clear_steer_rate() {
  steer_rate_ = 0;
}
inline double ControlReply::_internal_steer_rate() const {
  return steer_rate_;
}
inline double ControlReply::steer_rate() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlReply.steer_rate)
  return _internal_steer_rate();
}
inline void ControlReply::_internal_set_steer_rate(double value) {
  
  steer_rate_ = value;
}
inline void ControlReply::set_steer_rate(double value) {
  _internal_set_steer_rate(value);
  // @@protoc_insertion_point(field_set:lilsim.ControlReply.steer_rate)
}

// double ax = 4;
inline void ControlReply::clear_ax() {
  ax_ = 0;
}
inline double ControlReply::_internal_ax() const {
  return ax_;
}
inline double ControlReply::ax() const {
  // @@protoc_insertion_point(field_get:lilsim.ControlReply.ax)
  return _internal_ax();
}
inline void ControlReply::_internal_set_ax(double value) {
  
  ax_ = value;
}
inline void ControlReply::set_ax(double value) {
  _internal_set_ax(value);
  // @@protoc_insertion_point(field_set:lilsim.ControlReply.ax)
}

// -------------------------------------------------------------------

// SimParams

// double dt = 1;
inline void SimParams::clear_dt() {
  dt_ = 0;
}
inline double SimParams::_internal_dt() const {
  return dt_;
}
inline double SimParams::dt() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.dt)
  return _internal_dt();
}
inline void SimParams::_internal_set_dt(double value) {
  
  dt_ = value;
}
inline void SimParams::set_dt(double value) {
  _internal_set_dt(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.dt)
}

// double wheelbase = 2;
inline void SimParams::clear_wheelbase() {
  wheelbase_ = 0;
}
inline double SimParams::_internal_wheelbase() const {
  return wheelbase_;
}
inline double SimParams::wheelbase() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.wheelbase)
  return _internal_wheelbase();
}
inline void SimParams::_internal_set_wheelbase(double value) {
  
  wheelbase_ = value;
}
inline void SimParams::set_wheelbase(double value) {
  _internal_set_wheelbase(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.wheelbase)
}

// double v_max = 3;
inline void SimParams::clear_v_max() {
  v_max_ = 0;
}
inline double SimParams::_internal_v_max() const {
  return v_max_;
}
inline double SimParams::v_max() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.v_max)
  return _internal_v_max();
}
inline void SimParams::_internal_set_v_max(double value) {
  
  v_max_ = value;
}
inline void SimParams::set_v_max(double value) {
  _internal_set_v_max(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.v_max)
}

// double delta_max = 4;
inline void SimParams::clear_delta_max() {
  delta_max_ = 0;
}
inline double SimParams::_internal_delta_max() const {
  return delta_max_;
}
inline double SimParams::delta_max() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.delta_max)
  return _internal_delta_max();
}
inline void SimParams::_internal_set_delta_max(double value) {
  
  delta_max_ = value;
}
inline void SimParams::set_delta_max(double value) {
  _internal_set_delta_max(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.delta_max)
}

// double Lf = 5;
inline void SimParams::clear_lf() {
  lf_ = 0;
}
inline double SimParams::_internal_lf() const {
  return lf_;
}
inline double SimParams::lf() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.Lf)
  return _internal_lf();
}
inline void SimParams::_internal_set_lf(double value) {
  
  lf_ = value;
}
inline void SimParams::set_lf(double value) {
  _internal_set_lf(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.Lf)
}

// double ax_max = 6;
inline void SimParams::clear_ax_max() {
  ax_max_ = 0;
}
inline double SimParams::_internal_ax_max() const {
  return ax_max_;
}
inline double SimParams::ax_max() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.ax_max)
  return _internal_ax_max();
}
inline void SimParams::_internal_set_ax_max(double value) {
  
  ax_max_ = value;
}
inline void SimParams::set_ax_max(double value) {
  _internal_set_ax_max(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.ax_max)
}

// double steer_rate_max = 7;
inline void SimParams::clear_steer_rate_max() {
  steer_rate_max_ = 0;
}
inline double SimParams::_internal_steer_rate_max() const {
  return steer_rate_max_;
}
inline double SimParams::steer_rate_max() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.steer_rate_max)
  return _internal_steer_rate_max();
}
inline void SimParams::_internal_set_steer_rate_max(double value) {
  
  steer_rate_max_ = value;
}
inline void SimParams::set_steer_rate_max(double value) {
  _internal_set_steer_rate_max(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.steer_rate_max)
}

// .lilsim.SteeringInputMode steering_mode = 8;
inline void SimParams::clear_steering_mode() {
  steering_mode_ = 0;
}
inline ::lilsim::SteeringInputMode SimParams::_internal_steering_mode() const {
  return static_cast< ::lilsim::SteeringInputMode >(steering_mode_);
}
inline ::lilsim::SteeringInputMode SimParams::steering_mode() const {
  // @@protoc_insertion_point(field_get:lilsim.SimParams.steering_mode)
  return _internal_steering_mode();
}
inline void SimParams::_internal_set_steering_mode(::lilsim::SteeringInputMode value) {
  
  steering_mode_ = value;
}
inline void SimParams::set_steering_mode(::lilsim::SteeringInputMode value) {
  _internal_set_steering_mode(value);
  // @@protoc_insertion_point(field_set:lilsim.SimParams.steering_mode)
}

// -------------------------------------------------------------------

// AdminCommand

// .lilsim.Header header = 1;
inline bool AdminCommand::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AdminCommand::has_header() const {
  return _internal_has_header();
}
inline void AdminCommand::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& AdminCommand::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& AdminCommand::header() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminCommand.header)
  return _internal_header();
}
inline void AdminCommand::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.AdminCommand.header)
}
inline ::lilsim::Header* AdminCommand::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* AdminCommand::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.AdminCommand.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* AdminCommand::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* AdminCommand::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.AdminCommand.header)
  return _internal_mutable_header();
}
inline void AdminCommand::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.AdminCommand.header)
}

// .lilsim.AdminCommandType type = 2;
inline void AdminCommand::clear_type() {
  type_ = 0;
}
inline ::lilsim::AdminCommandType AdminCommand::_internal_type() const {
  return static_cast< ::lilsim::AdminCommandType >(type_);
}
inline ::lilsim::AdminCommandType AdminCommand::type() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminCommand.type)
  return _internal_type();
}
inline void AdminCommand::_internal_set_type(::lilsim::AdminCommandType value) {
  
  type_ = value;
}
inline void AdminCommand::set_type(::lilsim::AdminCommandType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:lilsim.AdminCommand.type)
}

// uint64 step_count = 3;
inline void AdminCommand::clear_step_count() {
  step_count_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AdminCommand::_internal_step_count() const {
  return step_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 AdminCommand::step_count() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminCommand.step_count)
  return _internal_step_count();
}
inline void AdminCommand::_internal_set_step_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  step_count_ = value;
}
inline void AdminCommand::set_step_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_step_count(value);
  // @@protoc_insertion_point(field_set:lilsim.AdminCommand.step_count)
}

// .lilsim.SimParams params = 4;
inline bool AdminCommand::_internal_has_params() const {
  return this != internal_default_instance() && params_ != nullptr;
}
inline bool AdminCommand::has_params() const {
  return _internal_has_params();
}
inline void AdminCommand::clear_params() {
  if (GetArena() == nullptr && params_ != nullptr) {
    delete params_;
  }
  params_ = nullptr;
}
inline const ::lilsim::SimParams& AdminCommand::_internal_params() const {
  const ::lilsim::SimParams* p = params_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::SimParams*>(
      &::lilsim::_SimParams_default_instance_);
}
inline const ::lilsim::SimParams& AdminCommand::params() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminCommand.params)
  return _internal_params();
}
inline void AdminCommand::unsafe_arena_set_allocated_params(
    ::lilsim::SimParams* params) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(params_);
  }
  params_ = params;
  if (params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.AdminCommand.params)
}
inline ::lilsim::SimParams* AdminCommand::release_params() {
  auto temp = unsafe_arena_release_params();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::SimParams* AdminCommand::unsafe_arena_release_params() {
  // @@protoc_insertion_point(field_release:lilsim.AdminCommand.params)
  
  ::lilsim::SimParams* temp = params_;
  params_ = nullptr;
  return temp;
}
inline ::lilsim::SimParams* AdminCommand::_internal_mutable_params() {
  
  if (params_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::SimParams>(GetArena());
    params_ = p;
  }
  return params_;
}
inline ::lilsim::SimParams* AdminCommand::mutable_params() {
  // @@protoc_insertion_point(field_mutable:lilsim.AdminCommand.params)
  return _internal_mutable_params();
}
inline void AdminCommand::set_allocated_params(::lilsim::SimParams* params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete params_;
  }
  if (params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(params);
    if (message_arena != submessage_arena) {
      params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:lilsim.AdminCommand.params)
}

// bool sync_mode = 5;
inline void AdminCommand::clear_sync_mode() {
  sync_mode_ = false;
}
inline bool AdminCommand::_internal_sync_mode() const {
  return sync_mode_;
}
inline bool AdminCommand::sync_mode() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminCommand.sync_mode)
  return _internal_sync_mode();
}
inline void AdminCommand::_internal_set_sync_mode(bool value) {
  
  sync_mode_ = value;
}
inline void AdminCommand::set_sync_mode(bool value) {
  _internal_set_sync_mode(value);
  // @@protoc_insertion_point(field_set:lilsim.AdminCommand.sync_mode)
}

// uint32 control_period_ms = 6;
inline void AdminCommand::clear_control_period_ms() {
  control_period_ms_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AdminCommand::_internal_control_period_ms() const {
  return control_period_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AdminCommand::control_period_ms() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminCommand.control_period_ms)
  return _internal_control_period_ms();
}
inline void AdminCommand::_internal_set_control_period_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  control_period_ms_ = value;
}
inline void AdminCommand::set_control_period_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_control_period_ms(value);
  // @@protoc_insertion_point(field_set:lilsim.AdminCommand.control_period_ms)
}

// -------------------------------------------------------------------

// AdminReply

// .lilsim.Header header = 1;
inline bool AdminReply::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool AdminReply::has_header() const {
  return _internal_has_header();
}
inline void AdminReply::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& AdminReply::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& AdminReply::header() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminReply.header)
  return _internal_header();
}
inline void AdminReply::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.AdminReply.header)
}
inline ::lilsim::Header* AdminReply::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* AdminReply::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.AdminReply.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* AdminReply::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* AdminReply::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.AdminReply.header)
  return _internal_mutable_header();
}
inline void AdminReply::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.AdminReply.header)
}

// bool success = 2;
inline void AdminReply::clear_success() {
  success_ = false;
}
inline bool AdminReply::_internal_success() const {
  return success_;
}
inline bool AdminReply::success() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminReply.success)
  return _internal_success();
}
inline void AdminReply::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void AdminReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:lilsim.AdminReply.success)
}

// string message = 3;
inline void AdminReply::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& AdminReply::message() const {
  // @@protoc_insertion_point(field_get:lilsim.AdminReply.message)
  return _internal_message();
}
inline void AdminReply::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:lilsim.AdminReply.message)
}
inline std::string* AdminReply::mutable_message() {
  // @@protoc_insertion_point(field_mutable:lilsim.AdminReply.message)
  return _internal_mutable_message();
}
inline const std::string& AdminReply::_internal_message() const {
  return message_.Get();
}
inline void AdminReply::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void AdminReply::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lilsim.AdminReply.message)
}
inline void AdminReply::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lilsim.AdminReply.message)
}
inline void AdminReply::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lilsim.AdminReply.message)
}
inline std::string* AdminReply::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* AdminReply::release_message() {
  // @@protoc_insertion_point(field_release:lilsim.AdminReply.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void AdminReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lilsim.AdminReply.message)
}
inline std::string* AdminReply::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lilsim.AdminReply.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void AdminReply::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.AdminReply.message)
}

// -------------------------------------------------------------------

// Color

// uint32 r = 1;
inline void Color::clear_r() {
  r_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_r() const {
  return r_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::r() const {
  // @@protoc_insertion_point(field_get:lilsim.Color.r)
  return _internal_r();
}
inline void Color::_internal_set_r(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  r_ = value;
}
inline void Color::set_r(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:lilsim.Color.r)
}

// uint32 g = 2;
inline void Color::clear_g() {
  g_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_g() const {
  return g_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::g() const {
  // @@protoc_insertion_point(field_get:lilsim.Color.g)
  return _internal_g();
}
inline void Color::_internal_set_g(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  g_ = value;
}
inline void Color::set_g(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_g(value);
  // @@protoc_insertion_point(field_set:lilsim.Color.g)
}

// uint32 b = 3;
inline void Color::clear_b() {
  b_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_b() const {
  return b_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::b() const {
  // @@protoc_insertion_point(field_get:lilsim.Color.b)
  return _internal_b();
}
inline void Color::_internal_set_b(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  b_ = value;
}
inline void Color::set_b(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_b(value);
  // @@protoc_insertion_point(field_set:lilsim.Color.b)
}

// uint32 a = 4;
inline void Color::clear_a() {
  a_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::_internal_a() const {
  return a_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Color::a() const {
  // @@protoc_insertion_point(field_get:lilsim.Color.a)
  return _internal_a();
}
inline void Color::_internal_set_a(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  a_ = value;
}
inline void Color::set_a(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_a(value);
  // @@protoc_insertion_point(field_set:lilsim.Color.a)
}

// -------------------------------------------------------------------

// Scale2D

// float x = 1;
inline void Scale2D::clear_x() {
  x_ = 0;
}
inline float Scale2D::_internal_x() const {
  return x_;
}
inline float Scale2D::x() const {
  // @@protoc_insertion_point(field_get:lilsim.Scale2D.x)
  return _internal_x();
}
inline void Scale2D::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Scale2D::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:lilsim.Scale2D.x)
}

// float y = 2;
inline void Scale2D::clear_y() {
  y_ = 0;
}
inline float Scale2D::_internal_y() const {
  return y_;
}
inline float Scale2D::y() const {
  // @@protoc_insertion_point(field_get:lilsim.Scale2D.y)
  return _internal_y();
}
inline void Scale2D::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Scale2D::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:lilsim.Scale2D.y)
}

// -------------------------------------------------------------------

// SE2

// double x = 1;
inline void SE2::clear_x() {
  x_ = 0;
}
inline double SE2::_internal_x() const {
  return x_;
}
inline double SE2::x() const {
  // @@protoc_insertion_point(field_get:lilsim.SE2.x)
  return _internal_x();
}
inline void SE2::_internal_set_x(double value) {
  
  x_ = value;
}
inline void SE2::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:lilsim.SE2.x)
}

// double y = 2;
inline void SE2::clear_y() {
  y_ = 0;
}
inline double SE2::_internal_y() const {
  return y_;
}
inline double SE2::y() const {
  // @@protoc_insertion_point(field_get:lilsim.SE2.y)
  return _internal_y();
}
inline void SE2::_internal_set_y(double value) {
  
  y_ = value;
}
inline void SE2::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:lilsim.SE2.y)
}

// double yaw = 3;
inline void SE2::clear_yaw() {
  yaw_ = 0;
}
inline double SE2::_internal_yaw() const {
  return yaw_;
}
inline double SE2::yaw() const {
  // @@protoc_insertion_point(field_get:lilsim.SE2.yaw)
  return _internal_yaw();
}
inline void SE2::_internal_set_yaw(double value) {
  
  yaw_ = value;
}
inline void SE2::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:lilsim.SE2.yaw)
}

// -------------------------------------------------------------------

// Pose

// double x = 1;
inline void Pose::clear_x() {
  x_ = 0;
}
inline double Pose::_internal_x() const {
  return x_;
}
inline double Pose::x() const {
  // @@protoc_insertion_point(field_get:lilsim.Pose.x)
  return _internal_x();
}
inline void Pose::_internal_set_x(double value) {
  
  x_ = value;
}
inline void Pose::set_x(double value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:lilsim.Pose.x)
}

// double y = 2;
inline void Pose::clear_y() {
  y_ = 0;
}
inline double Pose::_internal_y() const {
  return y_;
}
inline double Pose::y() const {
  // @@protoc_insertion_point(field_get:lilsim.Pose.y)
  return _internal_y();
}
inline void Pose::_internal_set_y(double value) {
  
  y_ = value;
}
inline void Pose::set_y(double value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:lilsim.Pose.y)
}

// double yaw = 3;
inline void Pose::clear_yaw() {
  yaw_ = 0;
}
inline double Pose::_internal_yaw() const {
  return yaw_;
}
inline double Pose::yaw() const {
  // @@protoc_insertion_point(field_get:lilsim.Pose.yaw)
  return _internal_yaw();
}
inline void Pose::_internal_set_yaw(double value) {
  
  yaw_ = value;
}
inline void Pose::set_yaw(double value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:lilsim.Pose.yaw)
}

// -------------------------------------------------------------------

// Marker

// string ns = 1;
inline void Marker::clear_ns() {
  ns_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Marker::ns() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.ns)
  return _internal_ns();
}
inline void Marker::set_ns(const std::string& value) {
  _internal_set_ns(value);
  // @@protoc_insertion_point(field_set:lilsim.Marker.ns)
}
inline std::string* Marker::mutable_ns() {
  // @@protoc_insertion_point(field_mutable:lilsim.Marker.ns)
  return _internal_mutable_ns();
}
inline const std::string& Marker::_internal_ns() const {
  return ns_.Get();
}
inline void Marker::_internal_set_ns(const std::string& value) {
  
  ns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Marker::set_ns(std::string&& value) {
  
  ns_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lilsim.Marker.ns)
}
inline void Marker::set_ns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lilsim.Marker.ns)
}
inline void Marker::set_ns(const char* value,
    size_t size) {
  
  ns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lilsim.Marker.ns)
}
inline std::string* Marker::_internal_mutable_ns() {
  
  return ns_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Marker::release_ns() {
  // @@protoc_insertion_point(field_release:lilsim.Marker.ns)
  return ns_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Marker::set_allocated_ns(std::string* ns) {
  if (ns != nullptr) {
    
  } else {
    
  }
  ns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ns,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lilsim.Marker.ns)
}
inline std::string* Marker::unsafe_arena_release_ns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lilsim.Marker.ns)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ns_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Marker::unsafe_arena_set_allocated_ns(
    std::string* ns) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ns != nullptr) {
    
  } else {
    
  }
  ns_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ns, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.Marker.ns)
}

// int32 id = 2;
inline void Marker::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Marker::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Marker::id() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.id)
  return _internal_id();
}
inline void Marker::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void Marker::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:lilsim.Marker.id)
}

// .lilsim.MarkerType type = 3;
inline void Marker::clear_type() {
  type_ = 0;
}
inline ::lilsim::MarkerType Marker::_internal_type() const {
  return static_cast< ::lilsim::MarkerType >(type_);
}
inline ::lilsim::MarkerType Marker::type() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.type)
  return _internal_type();
}
inline void Marker::_internal_set_type(::lilsim::MarkerType value) {
  
  type_ = value;
}
inline void Marker::set_type(::lilsim::MarkerType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:lilsim.Marker.type)
}

// .lilsim.Pose pose = 4;
inline bool Marker::_internal_has_pose() const {
  return this != internal_default_instance() && pose_ != nullptr;
}
inline bool Marker::has_pose() const {
  return _internal_has_pose();
}
inline void Marker::clear_pose() {
  if (GetArena() == nullptr && pose_ != nullptr) {
    delete pose_;
  }
  pose_ = nullptr;
}
inline const ::lilsim::Pose& Marker::_internal_pose() const {
  const ::lilsim::Pose* p = pose_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Pose*>(
      &::lilsim::_Pose_default_instance_);
}
inline const ::lilsim::Pose& Marker::pose() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.pose)
  return _internal_pose();
}
inline void Marker::unsafe_arena_set_allocated_pose(
    ::lilsim::Pose* pose) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pose_);
  }
  pose_ = pose;
  if (pose) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.Marker.pose)
}
inline ::lilsim::Pose* Marker::release_pose() {
  auto temp = unsafe_arena_release_pose();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Pose* Marker::unsafe_arena_release_pose() {
  // @@protoc_insertion_point(field_release:lilsim.Marker.pose)
  
  ::lilsim::Pose* temp = pose_;
  pose_ = nullptr;
  return temp;
}
inline ::lilsim::Pose* Marker::_internal_mutable_pose() {
  
  if (pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Pose>(GetArena());
    pose_ = p;
  }
  return pose_;
}
inline ::lilsim::Pose* Marker::mutable_pose() {
  // @@protoc_insertion_point(field_mutable:lilsim.Marker.pose)
  return _internal_mutable_pose();
}
inline void Marker::set_allocated_pose(::lilsim::Pose* pose) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pose_;
  }
  if (pose) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pose);
    if (message_arena != submessage_arena) {
      pose = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pose, submessage_arena);
    }
    
  } else {
    
  }
  pose_ = pose;
  // @@protoc_insertion_point(field_set_allocated:lilsim.Marker.pose)
}

// .lilsim.Color color = 5;
inline bool Marker::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool Marker::has_color() const {
  return _internal_has_color();
}
inline void Marker::clear_color() {
  if (GetArena() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::lilsim::Color& Marker::_internal_color() const {
  const ::lilsim::Color* p = color_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Color*>(
      &::lilsim::_Color_default_instance_);
}
inline const ::lilsim::Color& Marker::color() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.color)
  return _internal_color();
}
inline void Marker::unsafe_arena_set_allocated_color(
    ::lilsim::Color* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.Marker.color)
}
inline ::lilsim::Color* Marker::release_color() {
  auto temp = unsafe_arena_release_color();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Color* Marker::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:lilsim.Marker.color)
  
  ::lilsim::Color* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::lilsim::Color* Marker::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Color>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::lilsim::Color* Marker::mutable_color() {
  // @@protoc_insertion_point(field_mutable:lilsim.Marker.color)
  return _internal_mutable_color();
}
inline void Marker::set_allocated_color(::lilsim::Color* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:lilsim.Marker.color)
}

// .lilsim.Scale2D scale = 6;
inline bool Marker::_internal_has_scale() const {
  return this != internal_default_instance() && scale_ != nullptr;
}
inline bool Marker::has_scale() const {
  return _internal_has_scale();
}
inline void Marker::clear_scale() {
  if (GetArena() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
}
inline const ::lilsim::Scale2D& Marker::_internal_scale() const {
  const ::lilsim::Scale2D* p = scale_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Scale2D*>(
      &::lilsim::_Scale2D_default_instance_);
}
inline const ::lilsim::Scale2D& Marker::scale() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.scale)
  return _internal_scale();
}
inline void Marker::unsafe_arena_set_allocated_scale(
    ::lilsim::Scale2D* scale) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale_);
  }
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.Marker.scale)
}
inline ::lilsim::Scale2D* Marker::release_scale() {
  auto temp = unsafe_arena_release_scale();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Scale2D* Marker::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:lilsim.Marker.scale)
  
  ::lilsim::Scale2D* temp = scale_;
  scale_ = nullptr;
  return temp;
}
inline ::lilsim::Scale2D* Marker::_internal_mutable_scale() {
  
  if (scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Scale2D>(GetArena());
    scale_ = p;
  }
  return scale_;
}
inline ::lilsim::Scale2D* Marker::mutable_scale() {
  // @@protoc_insertion_point(field_mutable:lilsim.Marker.scale)
  return _internal_mutable_scale();
}
inline void Marker::set_allocated_scale(::lilsim::Scale2D* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:lilsim.Marker.scale)
}

// string text = 7;
inline void Marker::clear_text() {
  text_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Marker::text() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.text)
  return _internal_text();
}
inline void Marker::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:lilsim.Marker.text)
}
inline std::string* Marker::mutable_text() {
  // @@protoc_insertion_point(field_mutable:lilsim.Marker.text)
  return _internal_mutable_text();
}
inline const std::string& Marker::_internal_text() const {
  return text_.Get();
}
inline void Marker::_internal_set_text(const std::string& value) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Marker::set_text(std::string&& value) {
  
  text_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lilsim.Marker.text)
}
inline void Marker::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lilsim.Marker.text)
}
inline void Marker::set_text(const char* value,
    size_t size) {
  
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lilsim.Marker.text)
}
inline std::string* Marker::_internal_mutable_text() {
  
  return text_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Marker::release_text() {
  // @@protoc_insertion_point(field_release:lilsim.Marker.text)
  return text_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Marker::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lilsim.Marker.text)
}
inline std::string* Marker::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lilsim.Marker.text)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return text_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Marker::unsafe_arena_set_allocated_text(
    std::string* text) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (text != nullptr) {
    
  } else {
    
  }
  text_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      text, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.Marker.text)
}

// repeated .lilsim.Pose points = 8;
inline int Marker::_internal_points_size() const {
  return points_.size();
}
inline int Marker::points_size() const {
  return _internal_points_size();
}
inline void Marker::clear_points() {
  points_.Clear();
}
inline ::lilsim::Pose* Marker::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:lilsim.Marker.points)
  return points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Pose >*
Marker::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:lilsim.Marker.points)
  return &points_;
}
inline const ::lilsim::Pose& Marker::_internal_points(int index) const {
  return points_.Get(index);
}
inline const ::lilsim::Pose& Marker::points(int index) const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.points)
  return _internal_points(index);
}
inline ::lilsim::Pose* Marker::_internal_add_points() {
  return points_.Add();
}
inline ::lilsim::Pose* Marker::add_points() {
  // @@protoc_insertion_point(field_add:lilsim.Marker.points)
  return _internal_add_points();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Pose >&
Marker::points() const {
  // @@protoc_insertion_point(field_list:lilsim.Marker.points)
  return points_;
}

// double ttl_sec = 9;
inline void Marker::clear_ttl_sec() {
  ttl_sec_ = 0;
}
inline double Marker::_internal_ttl_sec() const {
  return ttl_sec_;
}
inline double Marker::ttl_sec() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.ttl_sec)
  return _internal_ttl_sec();
}
inline void Marker::_internal_set_ttl_sec(double value) {
  
  ttl_sec_ = value;
}
inline void Marker::set_ttl_sec(double value) {
  _internal_set_ttl_sec(value);
  // @@protoc_insertion_point(field_set:lilsim.Marker.ttl_sec)
}

// bool visible = 10;
inline void Marker::clear_visible() {
  visible_ = false;
}
inline bool Marker::_internal_visible() const {
  return visible_;
}
inline bool Marker::visible() const {
  // @@protoc_insertion_point(field_get:lilsim.Marker.visible)
  return _internal_visible();
}
inline void Marker::_internal_set_visible(bool value) {
  
  visible_ = value;
}
inline void Marker::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:lilsim.Marker.visible)
}

// -------------------------------------------------------------------

// MarkerArray

// .lilsim.Header header = 1;
inline bool MarkerArray::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool MarkerArray::has_header() const {
  return _internal_has_header();
}
inline void MarkerArray::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& MarkerArray::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& MarkerArray::header() const {
  // @@protoc_insertion_point(field_get:lilsim.MarkerArray.header)
  return _internal_header();
}
inline void MarkerArray::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.MarkerArray.header)
}
inline ::lilsim::Header* MarkerArray::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* MarkerArray::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.MarkerArray.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* MarkerArray::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* MarkerArray::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.MarkerArray.header)
  return _internal_mutable_header();
}
inline void MarkerArray::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.MarkerArray.header)
}

// repeated .lilsim.Marker markers = 2;
inline int MarkerArray::_internal_markers_size() const {
  return markers_.size();
}
inline int MarkerArray::markers_size() const {
  return _internal_markers_size();
}
inline void MarkerArray::clear_markers() {
  markers_.Clear();
}
inline ::lilsim::Marker* MarkerArray::mutable_markers(int index) {
  // @@protoc_insertion_point(field_mutable:lilsim.MarkerArray.markers)
  return markers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Marker >*
MarkerArray::mutable_markers() {
  // @@protoc_insertion_point(field_mutable_list:lilsim.MarkerArray.markers)
  return &markers_;
}
inline const ::lilsim::Marker& MarkerArray::_internal_markers(int index) const {
  return markers_.Get(index);
}
inline const ::lilsim::Marker& MarkerArray::markers(int index) const {
  // @@protoc_insertion_point(field_get:lilsim.MarkerArray.markers)
  return _internal_markers(index);
}
inline ::lilsim::Marker* MarkerArray::_internal_add_markers() {
  return markers_.Add();
}
inline ::lilsim::Marker* MarkerArray::add_markers() {
  // @@protoc_insertion_point(field_add:lilsim.MarkerArray.markers)
  return _internal_add_markers();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::lilsim::Marker >&
MarkerArray::markers() const {
  // @@protoc_insertion_point(field_list:lilsim.MarkerArray.markers)
  return markers_;
}

// -------------------------------------------------------------------

// MarkerCommand

// .lilsim.Header header = 1;
inline bool MarkerCommand::_internal_has_header() const {
  return this != internal_default_instance() && header_ != nullptr;
}
inline bool MarkerCommand::has_header() const {
  return _internal_has_header();
}
inline void MarkerCommand::clear_header() {
  if (GetArena() == nullptr && header_ != nullptr) {
    delete header_;
  }
  header_ = nullptr;
}
inline const ::lilsim::Header& MarkerCommand::_internal_header() const {
  const ::lilsim::Header* p = header_;
  return p != nullptr ? *p : *reinterpret_cast<const ::lilsim::Header*>(
      &::lilsim::_Header_default_instance_);
}
inline const ::lilsim::Header& MarkerCommand::header() const {
  // @@protoc_insertion_point(field_get:lilsim.MarkerCommand.header)
  return _internal_header();
}
inline void MarkerCommand::unsafe_arena_set_allocated_header(
    ::lilsim::Header* header) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.MarkerCommand.header)
}
inline ::lilsim::Header* MarkerCommand::release_header() {
  auto temp = unsafe_arena_release_header();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::lilsim::Header* MarkerCommand::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:lilsim.MarkerCommand.header)
  
  ::lilsim::Header* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::lilsim::Header* MarkerCommand::_internal_mutable_header() {
  
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::lilsim::Header>(GetArena());
    header_ = p;
  }
  return header_;
}
inline ::lilsim::Header* MarkerCommand::mutable_header() {
  // @@protoc_insertion_point(field_mutable:lilsim.MarkerCommand.header)
  return _internal_mutable_header();
}
inline void MarkerCommand::set_allocated_header(::lilsim::Header* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    
  } else {
    
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:lilsim.MarkerCommand.header)
}

// .lilsim.MarkerCommandType type = 2;
inline void MarkerCommand::clear_type() {
  type_ = 0;
}
inline ::lilsim::MarkerCommandType MarkerCommand::_internal_type() const {
  return static_cast< ::lilsim::MarkerCommandType >(type_);
}
inline ::lilsim::MarkerCommandType MarkerCommand::type() const {
  // @@protoc_insertion_point(field_get:lilsim.MarkerCommand.type)
  return _internal_type();
}
inline void MarkerCommand::_internal_set_type(::lilsim::MarkerCommandType value) {
  
  type_ = value;
}
inline void MarkerCommand::set_type(::lilsim::MarkerCommandType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:lilsim.MarkerCommand.type)
}

// string ns = 3;
inline void MarkerCommand::clear_ns() {
  ns_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& MarkerCommand::ns() const {
  // @@protoc_insertion_point(field_get:lilsim.MarkerCommand.ns)
  return _internal_ns();
}
inline void MarkerCommand::set_ns(const std::string& value) {
  _internal_set_ns(value);
  // @@protoc_insertion_point(field_set:lilsim.MarkerCommand.ns)
}
inline std::string* MarkerCommand::mutable_ns() {
  // @@protoc_insertion_point(field_mutable:lilsim.MarkerCommand.ns)
  return _internal_mutable_ns();
}
inline const std::string& MarkerCommand::_internal_ns() const {
  return ns_.Get();
}
inline void MarkerCommand::_internal_set_ns(const std::string& value) {
  
  ns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void MarkerCommand::set_ns(std::string&& value) {
  
  ns_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:lilsim.MarkerCommand.ns)
}
inline void MarkerCommand::set_ns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  ns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:lilsim.MarkerCommand.ns)
}
inline void MarkerCommand::set_ns(const char* value,
    size_t size) {
  
  ns_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:lilsim.MarkerCommand.ns)
}
inline std::string* MarkerCommand::_internal_mutable_ns() {
  
  return ns_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* MarkerCommand::release_ns() {
  // @@protoc_insertion_point(field_release:lilsim.MarkerCommand.ns)
  return ns_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void MarkerCommand::set_allocated_ns(std::string* ns) {
  if (ns != nullptr) {
    
  } else {
    
  }
  ns_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ns,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:lilsim.MarkerCommand.ns)
}
inline std::string* MarkerCommand::unsafe_arena_release_ns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:lilsim.MarkerCommand.ns)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return ns_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void MarkerCommand::unsafe_arena_set_allocated_ns(
    std::string* ns) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ns != nullptr) {
    
  } else {
    
  }
  ns_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ns, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lilsim.MarkerCommand.ns)
}

// int32 id = 4;
inline void MarkerCommand::clear_id() {
  id_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MarkerCommand::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MarkerCommand::id() const {
  // @@protoc_insertion_point(field_get:lilsim.MarkerCommand.id)
  return _internal_id();
}
inline void MarkerCommand::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  id_ = value;
}
inline void MarkerCommand::set_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:lilsim.MarkerCommand.id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace lilsim

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::lilsim::AdminCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lilsim::AdminCommandType>() {
  return ::lilsim::AdminCommandType_descriptor();
}
template <> struct is_proto_enum< ::lilsim::SteeringInputMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lilsim::SteeringInputMode>() {
  return ::lilsim::SteeringInputMode_descriptor();
}
template <> struct is_proto_enum< ::lilsim::MarkerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lilsim::MarkerType>() {
  return ::lilsim::MarkerType_descriptor();
}
template <> struct is_proto_enum< ::lilsim::MarkerCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lilsim::MarkerCommandType>() {
  return ::lilsim::MarkerCommandType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_messages_2eproto
